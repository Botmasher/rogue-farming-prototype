using System.Collections;
using System.Collections.Generic;
using UnityEngine;

public class Rogue : MonoBehaviour {

	// TODO: (? FeedObstacle) use castle int stats for strength and toughness, or for chests as theft
	// - rogue will do one attempt, take a hit to a stat, then do another attempt
	// - hits to armor reduce damage to health, but health still always hit
	// - attempts hit from weapon stat or from thievery stat
	// - successful treasures add to gold stash to be brought back

	// TODO: implement feedback from rogue-castle playtest
	// - gold countup / reporting and logging not incrementing correctly (pile took treasure from 0 to 9)
	// - the names were fun though
	// - bosses (and minibosses?) are evadable exactly as often as enemies
	// - lockout period prohibited clean manual playthrough

	// main stat for rogue life - deplete this to end planting
	int health;					// updated while adventuring
	public int maxHealth = 3; 	// intended to be read when brought back to life - ? updated through stats or items
	public bool isAlive = true;

	// note which object killed rogue this run - useful for epitaph ui
	public string deathDealerName;
	public string deathDealerType;

//	// check for currently acting rogue
//	// NOTE: if updated after frame, cannot do async obstacles - consider coroutine for life/death actions like taking damage
//	public bool isBusy = false;

	// TODO: tighten storing vs equipping (see Equip and Unequip methods)
	// 	- some things work with armor and weapons by referencing the dictionary, others the go vars
	// 	- currently setting/unsetting both dictionary and g.o. in Equip, Unequip
	//	- storage is for the rogue and separate from Grim inventory
	// 	- storage may also include items for health, power, ...

	// weaponry and armor storage
	public Dictionary <string, GameObject> equipment = new Dictionary<string, GameObject> () {
		{ "armor", null },
		{ "weapon", null }
	};
	// starting equipment
	public GameObject armorEquipment;
	public GameObject weaponEquipment;

	// unique name generated for each rogue - see GenerateName below
	public string name;

	// amount of coin in pockets
	public int treasure = 0;

	// upgraded stats info to feed to upgrade interface
	public string runUpgradeText;

	// initialized stats leveled up each pass through castle
	public int attack = 0;
	public int defense = 0;
	public int thievery = 0;
	public int agility = 0;
	// factor pushing various events in rogue's favor
	public float luck = 0.05f;

	// determine skills gained in castle for boosts
	// 	- enemy used to upgrade health, attack, defense, equipment
	// 	- hazard used to upgrade agility, health
	// 	- luck used to upgrade luck
	// 	- treasure collected this pass and brought to reaper
	// 	- luck augmented from successful luck events like evasion or treasure opening
	Dictionary<string, float> runPoints = new Dictionary<string, float> () {
		{ "enemy", 0 },
		{ "treasure", 0 },
		{ "hazard", 0 },
		{ "luck", 0 }
	};

	void Start () {
		// pick a new rogue name
		// TODO: append generation on harvest / when calling Live()
		name = GenerateName ();
		gameObject.name = name;

		// set stats
		health = maxHealth;

		// hide the upgrades ui
		// NOTE: action taken by each rogue!
		//rogueUpgradeUI.SetActive(false);

		// store starting equipment
		if (weaponEquipment != null) equipment["weapon"] = weaponEquipment;
		if (armorEquipment != null) equipment ["armor"] = armorEquipment;
	}


	/* Name Generation */
	// TODO: read names generated by language builder tool
	List<string> preNames = new List<string> () {
		"Zurb",
		"Tank",
		"Sckyph",
		"Quirzt",
		"Snarg",
		"Bivliv",
		"Snipp",
		"Ter",
		"Count"
	};
	List<string> midNames = new List<string> () {
		"izar",
		"y",
		"ie",
		"ula",
		"ulus",
		"ia",
		"ius",
		"ence",
		"imus",
		"wa",
		"nu"
	};
	List<string> postNames = new List<string> () {
		"Happy",
		"Wise",
		"Unflinching",
		"Slippery",
		"Soft",
		"Aged",
		"Technical",
		"Newb",
		"Fresh",
		"Wandering",
		"Greedy",
		"Selfish",
		"Selfless",
		"Needy",
		"Prickly",
		"Allergic",
		"Notorious",
		"Epenthetic",
		"Raucous",
		"Nifty",
		"Tidiest",
		"Strange",
		"Magical",
		"Beastly",
		"Odious",
		"Hopeful",
		"Suffering",
		"Huntress"
	};
	string GenerateName () {
		string randomPreName = preNames [Random.Range(0, preNames.Count)];
		string randomMidName = midNames [Random.Range(0, midNames.Count)];
		string randomPostName = postNames [Random.Range(0, postNames.Count)];
		return string.Format ("{0}{1} the {2}", randomPreName, randomMidName, randomPostName);
	}


	/* Item and inventory interaction */

	// attach item to rogue equipment spot - created for Grim inventory management
	public bool Equip (GameObject item, bool switchOut=false) {
		// make sure the item is a piece of weapon or armor equipment
		// and attach if a spot is available within the rogue

		bool didAttach;

		// attach weapon item to behavior and object
		if (item.GetComponent<Weapon> () && (equipment ["weapon"] == null || switchOut)) {
			equipment ["weapon"] = item;
			weaponEquipment = item;
			item.transform.SetParent (this.transform);
			didAttach = true;
		}
		// attach armor item to behavior and object
		else if (item.GetComponent<Armor> () && (equipment ["armor"] == null || switchOut)) {
			equipment ["armor"] = item;
			armorEquipment = item;
			item.transform.SetParent (this.transform);
			didAttach = true;
		}
		// unequippable item 
		else {
			didAttach = false;
		}

		return didAttach;
	}

	// remove item from rogue equipment spot - for Grim inventory
	public bool Unequip (string itemKey=null) {
		// remove specific equipment entry
		if (equipment.ContainsKey (itemKey) && equipment[itemKey] != null) {
			equipment [itemKey] = null;

			// empty out references to weapons and armor outside the item dictionary
			if (itemKey == "weapon") {
				weaponEquipment = null;
			}
			if (itemKey == "armor") {
				armorEquipment = null;
			}

			return true;
		}
		// no valid equipment key or equipment entry
		return false;
	}

	// fetch equipment objects - created for Grim inventory
	public GameObject GetWeapon () {
		return equipment ["weapon"];
	}
	public GameObject GetArmor () {
		return equipment ["armor"];
	}

	// take treasure
	public int Plunder() {
		// fetch amount and empty pockets
		int plunderedTreasure = treasure;
		treasure = 0;
		return plunderedTreasure;
	}

	/* Castle interaction */

	// TODO: make obstacles GameObjects to combine features instead of balancing dictionaries and lists
	public bool FeedObstacle (CastleObstacle obstacle) {

		// TODO: just assign the obstacle, even let it communicate back to call the right methods in rogue

		// assign and react to the obstacle depending on its type
		switch (obstacle.obstacleType) {
		case "hazard":
			EvadeHazard (obstacle);
			break;

		case "enemy":
		case "boss":
		case "miniBoss":
		case "finalBoss":
			FightEnemy (obstacle);
			break;

		case "treasure":
			OpenTreasure (obstacle);
			break;

		default:
			return false;
		}

		return true;
	}

	// reset health, life checks and epitaph ui info
	public void Revive() {
		// update character life data
		isAlive = true;
		deathDealerName = "";
		deathDealerType = "";
		health = maxHealth;

		// clear out points gathered on the last run
		runPoints["enemy"] = 0;
		runPoints["treasure"] = 0;
		runPoints["hazard"] = 0;
		runPoints["luck"] = 0;
	}

	// flag as dead, upgrade stats, add epitaph ui info
	public void Die(string killerName, string killerType) {
		// tally points before death
		if (isAlive) {

			// set dead
			isAlive = false;

			// TODO: set stats based on successful actions this run
			//  - castle keeps memory of augments gained this run
			// 	- OR rogue keeps then empties them into skills

			/*
			 * 	Upgrade skills based on run stats
			 */
			int totalPoints = 1; 	// leave minimum one point to spend

			int enemyPoints = Mathf.RoundToInt (runPoints["enemy"]);
			int treasurePoints = Mathf.RoundToInt (runPoints ["treasure"]);
			int hazardPoints = Mathf.RoundToInt (runPoints ["hazard"]);

			totalPoints += enemyPoints > 0 ? 1 : 0;
			totalPoints += hazardPoints > 0 ? 1 : 0;
			totalPoints += treasurePoints > 0 ? 1 : 0;

			// update amount in pockets that can be plundered
			treasure += treasurePoints;

			Debug.Log ("Perished rogue has " + totalPoints + " points to spend");

			// TODO: decide where to spend points through UI
			//
			// here simulate arbitrarily picking skills
			List<string> skillNames = new List<string> {"attack", "defense", "health", "thievery", "agility"};
			List<string> selectedSkills = new List<string> ();
			//
			// spend each available point on a random skill until all spent
			while (totalPoints > 0) {
				string skillName = skillNames[Random.Range(0, skillNames.Count)];
				selectedSkills.Add (skillName);
				switch (skillName) {
					case "attack":
						Debug.Log ("Increasing attack...");
						attack++;
						break;
					case "defense":
						Debug.Log ("Increasing defense...");
						defense++;
						break;
					case "health":
						Debug.Log ("Increasing health...");
						maxHealth++;
						break;
					case "thievery":
						Debug.Log ("Increasing thievery...");
						thievery++;
						break;
					case "agility":
						Debug.Log ("Increasing agility...");
						agility++;
						break;
					default:
						break;
				}
				totalPoints--;
			}

			// luck goes up on its own
			float luckPoints = runPoints ["luck"];
			luck += luckPoints * 0.01f;

			// upgrade equipment based on run stats
			int equipmentPoints = enemyPoints * 10;
			Weapon weapon = weaponEquipment.GetComponent<Weapon> ();
			Armor armor = armorEquipment.GetComponent<Armor> ();
			weapon.AddXP (equipmentPoints);
			armor.AddXP (equipmentPoints);

			Debug.Log (string.Format ("Increased armor by {0}, weapon by {0}", equipmentPoints, equipmentPoints));


			// format text for ui - displayed when set active by Plot on rogue harvest
			string formattedStats = "<size=86><color=yellow><i>Rogue upgraded</i></color></size>\n";
			formattedStats += "<size=62>";
			foreach (string selectedSkill in selectedSkills) {
				formattedStats += "+1 to <b>" + selectedSkill + "</b>\n";
			}
			formattedStats += "<b>Weapon</b> gained <b>" + equipmentPoints + "</b>xp\n";
			formattedStats += "<b>Armor</b> gained <b>" + equipmentPoints + "</b>xp\n";
			formattedStats += "</size>";
			runUpgradeText = formattedStats;

			// remember what defeated rogue for epitaph text
			deathDealerName = killerName;
			deathDealerType = killerType;
			//Debug.Log (string.Format("Rogue {0} has perished in the Castle!", this.name));
		}
	}

	/* Adventuring through generated obstacles */

	void FightEnemy(CastleObstacle enemy) {
		// reference relevant values from enemy
		string enemyName = enemy.obstacleName;
		string enemyType = enemy.obstacleType;
		int enemyHealth = enemy.obstacleValue;
		int enemyAttack = enemy.obstacleValue;

		Debug.Log (string.Format("Rogue {0} is taking up arms against a {1}", this.name, enemyName));

		// roll for a zero-to-one plus luck chance for immediate evasion
		float rollPlusLuck = Random.Range (0f, 1f + this.luck);

		// attempt to run away from non-boss enemy
		// 	?- also try to evade "miniBoss"
		if (enemyType == "enemy" && rollPlusLuck > 0.8f) {
			Debug.Log (string.Format("{0} ran away from a {1}", this.name, enemyName));

			// store skills gained
			runPoints["enemy"] += (0.5f * enemyAttack);
			runPoints["luck"] += rollPlusLuck;

			return;
		}

		// play through encounter taking turns fighting and defending against the enemy
		CycleAttackDefend (enemyName, enemyType, enemyAttack, enemyHealth);
	}

	// handle enemy encounter until encounter resolves (rogue kills/evades enemy, enemy kills rogue)
	void CycleAttackDefend (string enemyName, string enemyType, int enemyAttack, int enemyHealth) {
		// roll again so not all events in a single turn are lucky or unlucky
		float rollPlusLuck = Random.Range (0f, 1f + luck);

		// rogue died on previous cycle - end encounter
		if (!isAlive) {
			return;
		}

		// attack enemy - leave a small chance to miss
		if (rollPlusLuck > 0.08f) {
			// deal damage with base attack plus weapon stats
			int rogueAttackStrength = Mathf.RoundToInt (
				attack + (attack * luck) + weaponEquipment.GetComponent<Weapon> ().damage
			);
			enemyHealth -= Mathf.Max(0, rogueAttackStrength);
			Debug.Log (string.Format("Did {0} damage to enemy {1}: {2}/{3}", rogueAttackStrength, enemyName, enemyHealth, enemyAttack));
		} else {
			Debug.Log (string.Format("Missed enemy {0}: {1}/{2}", enemyName, enemyHealth, enemyAttack));
		}

		// finish off dead enemy
		if (enemyHealth <= 0) {
			Debug.Log (string.Format("{0} defeated a {1}!", name, enemyName));
			// add to skills gained
			runPoints["enemy"] += enemyAttack;
			return;
		}

		// enemy counterattack
		// leave a small chance to evade non-bosses
		if (rollPlusLuck < 0.1f && enemyType == "enemy") {
			Debug.Log (string.Format("Evaded enemy attack - rogue health remains at {0}", health));
		}
		// unevaded or unevadable
		else {
			// defend with armor - use its stats to diminish damage taken
			int enemyAttackStrength = Mathf.RoundToInt(
				enemyAttack - (enemyAttack * luck) - defense - armorEquipment.GetComponent<Armor> ().defense
			);
			// subtract any positive amount of damage done from rogue health
			health -= Mathf.Max (0, enemyAttackStrength);
			Debug.Log (string.Format("Enemy attacked - rogue health dropped to {0}", health));
		}

		// rogue perishes once health done
		if (health <= 0) {
			Die (enemyName, enemyType);
		}

		// take another turn if enemy still alive
		if (enemyHealth > 0 && health > 0) {
			Debug.Log ("Taking another attack-defend turn against enemy " + enemyName);
			CycleAttackDefend (enemyName, enemyType, enemyAttack, enemyHealth);
		}
		return;
	}

	// unassign and reset treasure being opened
	void OpenTreasure (CastleObstacle treasure) {
		// peel off relevant treasure settings
		string treasureName = treasure.obstacleName;
		int treasureTrickiness = treasure.obstacleValue;

		Debug.Log (string.Format("Rogue {0} is struggling to open a {1}", this.name, treasureName));

		// roll for a zero-to-one plus luck chance
		float rollPlusLuck = Random.Range (0f, 1f + luck);

		// be sly or lucky enough to open
		if ((this.thievery >= treasureTrickiness) || (rollPlusLuck > (0.85f + (treasureTrickiness/100)))) {

			// store loot and skills gained
			runPoints["treasure"] += treasureTrickiness;
			runPoints["luck"] += rollPlusLuck;

			Debug.Log (string.Format ("Pried it! The {0} gold ups rogue treasure to {1}", treasureTrickiness, runPoints["treasure"]));

		} else {
			Debug.Log ("Failed to crack it open. Not yet thieverious enough for its secrets.");
		}
	}

	// unassign and reset hazard facing rogue
	void EvadeHazard (CastleObstacle hazard) {
		// peel off relevant hazard values
		string hazardName = hazard.obstacleName;
		int hazardAttack = hazard.obstacleValue;
		
		Debug.Log (string.Format("Rogue {0} is craftily evading a {1}", this.name, hazardName));

		// roll for a zero-to-one plus luck chance
		float rollPlusLuck = Random.Range (0f, 1f + this.luck);

		// be agile or lucky enough to evade
		if ((agility > hazardAttack) || (rollPlusLuck > (0.3f + (hazardAttack/100)))) {
			Debug.Log (string.Format("Smoothly sidestepped it! Health still {0}", this.health));
			return;

		} else {
			// determine hazard damage
			int hazardAttackStrength = Mathf.RoundToInt(
				hazardAttack - rollPlusLuck * (defense - armorEquipment.GetComponent<Armor> ().defense)
			);
			// decrease health by calculated damage
			this.health -= Mathf.Max(0, hazardAttackStrength);
			Debug.Log (string.Format("Stumbled into the {0} - health fell to {1}", hazardName, this.health));
		}

		if (this.health <= 0) {
			Die (hazardName, hazard.obstacleType);
			return;
		}

		// store skills gained
		runPoints["hazard"] += hazardAttack;
	}
}
